# Практическая работа №1
Шаршов Иван БИСО-03-20

# Прохождение курса по R в RStudio через командную строку библиотеки Swirl

## Цель работы

1.  Пройти обучение и познакомиться с синтаксисом языка программирования
    R;
2.  Оформить отчет по изученному материалу.

## Ход выполнения работы

Для начала загрузим пакет Swirl, выберем его во вкладке Packages и
введём в строку команду `swirl()`. Далее выбираем курс R Programming и
попадаем на список уроков, которые требуется сделать. Всего их 14, в
рамках работы надо сделать 4 урока.

### Урок №1: Основные блоки программирования на языке R

Самая простая форма, которая может использоваться в R - это
интерактивный калькулятор.

    > 5+7

    [1] 12

Чтобы не писать каждый раз одно и то же выражение, можно вынести его в
переменную “x”. После этого запросить вывод этой переменной.

    > x<-5+7
    > x

    [1] 12

Далее нужно создать новую переменную “y” и занести туда выражение
`x - 3`. После этого снова запросить вывод этой переменной.

    > y <- x - 3
    > y

    [1] 9

Далее создадим вектор через команду `c()` и занесём его в переменную
`z`.

    > z <- c(1.1, 9, 3.14)

Если возникнут вопросы по какой-либо команде, всегда можно добавить знак
вопроса (`?`) перед названием команды.

    > ?c

Посмотрим как записался вектор в переменной `z`.

    > z

    [1] 1.10 9.00 3.14

Можем скомбинировать вектора в один и вывести информацию на экран.
Например, создадим вектор из вектора `z`, 555, `z`.

    > c(z, 555, z)

    [1]   1.10   9.00   3.14 555.00   1.10   9.00   3.14

Также вектора могут использоваться в арифметических выражениях. Умножим
вектор `z` на 2 и прибавим к нему 100. Эти операции будут производиться
с каждым элементом вектора.

    > z * 2 + 100

    [1] 102.20 118.00 106.28

Наиболее часто встречающиеся операции `+`, `-`, `/`, `*`, `^` могут
прописываться напрямую. Однако чтобы вычислить корень, нужно
использовать команду `sqrt()`, а чтобы взять по модулю - `abs()`.
Попробуем вычислить корень из z - 1 и занести в переменную `my_sqrt`.
Затем узнаем что у нас получился вектор из 3-х чисел, так как вычисление
по корню применялось к каждому из них.

    > my_sqrt <- sqrt(z - 1)
    > my_sqrt

    [1] 0.3162278 2.8284271 1.4628739

Создадим новую переменную `my_div` и занесём туда результат деления
значений `z` на `my_sqrt`. Затем узнаем что получилось в итоге и
убедимся, что операция выполняется по элементам (т.е. первому элементу
первого вектора соответствует первый элемент второго вектора).

    > my_div <- z / my_sqrt
    > my_div

    [1] 3.478505 3.181981 2.146460

Когда вектора равны по длине, то операция вычисляется элемент к
элементу. Но если они разные, то самый короткий вектор повторяется
снова, пока более длинный не закончится. Выведем на экран результат
сложение 2-х векторов: `c(1, 2, 3, 4)` и `c(0, 10)`.

    > c(1, 2, 3, 4) + c(0, 10)

    [1]  1 12  3 14

В случае, если первый вектор закончился, а второй нет, то перебор
продолжится, то после вывода результата появится предупреждение “Более
длинная длина объекта не кратна более короткой длине объекта”

    > c(1, 2, 3, 4) + c(0, 10, 100)

    [1]   1  12 103   4

    Warning message:
    In c(1, 2, 3, 4) + c(0, 10, 100) :
      longer object length is not a multiple of shorter object length

Далее рассмотрим лайфхаки, которые сократят время. С помощью стрелок
вверх-вниз можно посмотреть какие команды были ранее. Это поможет при
отладке и просто в случаях, когда надо повторить команду. Найдём
выражение `z * 2 + 100` и поменяем `100` на `1000`.

    > z * 2 + 1000

    [1] 1002.20 1018.00 1006.28

В случае, если забыли верное название какой-то переменной, то на помощь
придёт `Tab`. Просто нужно ввести первые символы переменной и нажать на
табуляцию, чтобы появился список переменных с таким началом. Найдём
переменную `my_div` по началу `my_` и узнаем её значение.

    > my_div

    [1] 3.478505 3.181981 2.146460

### Урок №2: Рабочее пространство и файлы

Определим, какой каталог использует текущий сеанс R в качестве текущего
рабочего каталога, используя команду `getwd()`.

    > getwd()

    [1] "C:\Users\huawei\Desktop\Учёба\7 семестр\Захарчук\Threat_Hunting_7"

Выведем на экран все объекты локальной рабочей среды с помощью команды
`ls()`. Так как переменных изначально не было, на экран вывело
“character(0)”

    > ls()

    character(0)

Назначим 9 в x с помощью команды “x \<- 9”.

    > x <- 9

Теперь посмотрим на объекты локальной рабочей среды с помощью команды
“ls()”.

    > ls()

    [1] "x"

Выведем на экран все файлы рабочей директории с помощью команд
“list.files()” или “dir()”.

    > dir()

    [1] "lab_1.html"     "lab_1.qmd"      "lab_1_files"    "lab_1"           
    [5] "lab_1.md"         "lab_1.Rproj" "README.md"       "testdir"  

Попробуем функцию вызова информации по команде `list.files`.

    > ?list.files

Используя функцию `args()` мы можем узнать какие аргументы даёт введёная
в скобках функция. Посмотрим аргументы команды `list.files()`

    > args(list.files)
    function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
        recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
        no.. = FALSE) 
    NULL

Зададим в переменную `old.dir` нашу рабочую директорию. Это нужно, чтобы
в конце к ней вернуться.

    > old.dir <- getwd()

С помощью команды `dir.create()` создадим новый директорий с именем
`testdir` в уже существующий. Так как он был создан ранее, то программа
выдаст предупреждение.

    > dir.create("testdir")

    Warning message:
    In dir.create("testdir") : `testdir` already exists

Чтобы работать в этой директории, надо задать её как рабочую с помощью
команды `setwd()`.

    > setwd("testdir")

Создадим файл `mytest.R`, используя функцию `file.create()`.

    > file.create("mytest.R")

    [1] TRUE

Проверим, какие файлы у нас лежат в новой директории.

    > dir()

    [1] "mytest.R"

Чтобы проверить, существует ли `mytest.R` в рабочей директории,
используем команду `file.exists()`.

    > file.exists("mytest.R")

    [1] TRUE

Посмотрим информацию о файле `mytest.R`, используя команду
`file.info()`.

    > file.info("mytest.R")

             size isdir mode               mtime               ctime
    mytest.R    0 FALSE  666 2023-09-30 11:36:47 2023-09-28 15:47:09
                           atime exe
    mytest.R 2023-09-30 11:36:47  no

Переименуем файл `mytest.R` в `mytest2.R`, используя команду
`file.rename()`.

    > file.rename("mytest.R", "mytest2.R")

    [1] TRUE

Сделаем копию файла `mytest2.R` и назовём копию `mytest3.R`, используя
команду `file.copy()`.

    > file.copy("mytest2.R", "mytest3.R")

    [1] TRUE

Укажите родительский путь к файлу `mytest3.R`, используя команду
`file.path()`.

    > file.path("mytest3.R")

    [1] "mytest3.R"

Можно использовать `file.path()` для построения путей к файлам и
каталогам, которые не зависят от операционной системы, в которой
выполняется наш R-код. Передадим `folder1` и `folder2` в качестве
аргументов для создания независимого от платформы имени пути.

    > file.path("folder1", "folder2")

    [1] "folder1/folder2"

Посмотрим документацию команды `dir.create` с помощью вопросительного
знака.

    > ?dir.create

Создадим новый директорий в нашей рабочей директории и назовём его
`testdir2`, а также создадим сабдиректорий и назовём его `testdir3`,
используя только команды `dir.create()` и `file.path()`.

    > dir.create(file.path(`testdir2`, `testdir3`), recursive = TRUE)

Вернёмся обратно в рабочую директорию на компьютере, с помощью команды
`setwd()`. Вспомним, что ранее мы заносили её в переменную `old.dir`.

    > setwd(old.dir)

### Урок №3: Последовательности чисел

Самый простой способ создать последовательность чисел - использовать
оператор `:`. Введём `1:20`, чтобы увидеть как это работает.

    > 1:20

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Также мы можем создать последовательность из вещественных чисел. Для
этого используем команду `pi:10`, чтобы создать последовательность от
числа Пи.

    > pi:10

    [1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

Если поменять цифры местами, то получится обратный список
последовательности чисел. Попробуем перевернуть список с помощью команды
`15:1`.

    > 15:1

     [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

Важно помнить, что при запросе документации по оператору, его необходимо
заключить в `подобные` кавычки. Попробуем узнать информацию об операторе
`?`.

    > ?`:`

Существует операция `seq()`, аналогичная оператору `:`. Убедимся в этом
с помощью команды `seq(1, 20)`.

    > seq(1, 20)

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

Можно задать последовательность чисел и указать шаг, на который будет
сдвигаться генерация чисел. Создадим последовательность от 0 до 10 с
шагом 0.5 с помощью команды `seq(0, 20, by=0.5)`.

    > seq(0, 10, by=0.5)

     [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5
    [15]  7.0  7.5  8.0  8.5  9.0  9.5 10.0

Если нас не волнует, какое приращение задано и мы просто хотим создать
последовательность от 5 до 10, которое включает в себя 30 элементов.
Создадим данную последовательность через команду `seq(5, 10, length=30)`
и занесём её в переменную `my_seq`.

    > my_seq <- seq(5, 10, length=30)

Чтобы убедиться, что последовательность имеет длину 30, ипользуем
команду `length()`.

    > length(my_seq)

    [1] 30

Теперь посмотрим как мы можем комбинировать команды между собой.
Используем значение длины 30 и попробуем задать последовательность
`1:30` с использованием команды `length(my_seq)`.

    > 1:length(my_seq)

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
    [24] 24 25 26 27 28 29 30

Есть и другой вариант использования данной конструкции, используя
функцию `along.with`, которая берет длину из длины аргумента (замена
length()).

    > seq(along.with = my_seq)

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
    [24] 24 25 26 27 28 29 30

Однако, как и в случае со многими распространенными задачами, R имеет
отдельную встроенную функцию для этой цели, называемую `seq_along()`.
Она составляет на основе длины последловательности свою собственную.

    > seq_along(my_seq)

     [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
    [24] 24 25 26 27 28 29 30

Также существует функция повторения числа или вектора n-ное количество
раз. Создадим вектор, который содержит в себе 40 нулей с помощью команды
`rep(0, times = 40)`.

    > rep(0, times = 40)

     [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    [36] 0 0 0 0 0

Посмотрим как эта же функция можем справиться с векторами, созданными
через функцию `c(0, 1, 2)`. Повторим её 10 раз с помощью команды
`rep(c(0, 1, 2), times = 10)`.

    > rep(c(0, 1, 2), times = 10)

     [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

Стоит отметить, что если нам требуется повторить каждый элемент, то на
помощь придёт функция `each()`. Попробуем повторить 10 раз каждый из
элементов вектора `c(0, 1, 2)` с помощью команды
`rep(c(0, 1, 2), each = 10)`.

    > rep(c(0, 1, 2), each = 10)

     [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

### Урок №4: Векторы

Начнём с создания вектора чисел, который содержит значения `0.5`, `55`,
`-10`, `6` и занесён в переменную `num_vect`.

    > num_vect <- c(0.5, 55, -10, 6)

Далее создадим новую переменную `tf` и дадим ей значение результата
`num_vect < 1`. В итоге мы получим вектор, содержащий 4 логических
значения \[TRUE | FALSE\]

    > tf <- num_vect < 1

Выведем на экран значение переменной `tf`.

    > tf

    [1]  TRUE FALSE  TRUE FALSE

Далее выведем на экран результат работы команды `num_vect >= 6` без
занесения в переменную.

    > num_vect >= 6

    [1] FALSE  TRUE FALSE  TRUE

Далее необходимо пройти мини-тест, содержащий в себе 2 варианта ответа.

***Вопрос №1.***

    (3 > 5) & (4 == 4)
    FALSE & TRUE = FALSE

*Ответ:* FALSE

***Вопрос №2.***

    (TRUE == TRUE) | (TRUE == FALSE)
    TRUE | FALSE = TRUE

*Ответ:* TRUE

***Вопрос №3.***

    ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
    (TRUE | FALSE) & TRUE
    TRUE & TRUE

*Ответ:* TRUE

Вектора могут состоять не только из чисел, но и из символов. Для того,
чтобы задать в вектор символьные элементы, необходимо использовать
двойные кавычки-лапки `""`, чтобы обозначить строковый элемент. Зададим
вектор, состоящий из 3-х слов “My”, “name”, “is” и занесём его в
переменную `my_char`.

    > my_char <- c("My", "name", "is")

Выведем на экран значение вектора `my_char`.

    > my_char

    [1] "My"   "name" "is" 

Сейчас этот вектор имеет длину 3. Соединим его в один с помощью команды
`paste()` и добавим пробел, который будет соединять элементы
`collapse = " "`, а затем выведем всё на экран.

    > paste(my_char, collapse = " ")

    [1] "My name is"

Осталось только создать новый вектор и добавить туда своё имя. Создадим
новую переменную `my_name` и занесём туда новый результат.

    > my_name <- c(my_char, "Dasha")

Выведем на экран значение переменной `my_name`.

    > my_name

    [1] "My"     "name"   "is"     "Ivan"

Так как вектор записался по элементам, его нужно соединить, добавив
пробел между ними.

    > paste(my_name, collapse = " ")

    [1] "My name is Ivan"

Рассмотрим другой вариант - добавление соединяющего символа (пробела)
при объединении других с помощью команды `sep = " "`. Соединим слова
“Hello” и “world!”, добавив пробел между ними и выведем это на экран.

    > paste("Hello", "world!", sep = " ")

    [1] "Hello world!"

Рассмотрим вариант соединения двух векторов в один. Соединим вектор от 1
до 3 с вектором (“X”, “Y”, “Z”), не используя пробел как соединитель
между элементами.

    > paste(1:3, c("X","Y","Z"), sep = "")

    [1] "1X" "2Y" "3Z"

Если вектора имеют разную длину, то меньший вектор повторяется снова,
пока больший не закончится. Попробуем перебрать и соединить все буквы
латинского алфавита с вектором от 1 до 4, используя соединитель
`sep = "-"`. Команда `LETTERS` автоматически перебирает все буквы, без
нужды указывать каждую.

    > paste(LETTERS, 1:4, sep = "-")

     [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4"
    [13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
    [25] "Y-1" "Z-2"

## Оценка результатов

Пройдено 4 урока из интерактивного курса Swirl по основам языка R.

## Вывод

В результате выполнения работы были получены базовые навыки
программирования на языке R.
